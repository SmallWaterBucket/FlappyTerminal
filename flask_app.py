#Made by Semen Syzonenko 2025
#less then 1% of the code was generated by AI, like one function was straight up stolen from stack overflow, the rest was written by me,
# while most of the comments were started by me and autocompleted by AI (copilot).
# Future SmallWaterBucket here: the AI died for some reason and didn't want to autocomplete the comments after the third of the document size
#so i had to continue myself.

#tbh this code is greener (meaning comments) than greenpeace wants to make earth.
#This project took me quite some time so I'd appreciate if you shared it with your friends.


#to add:
#1) some info about the game

from flask import Flask, request, jsonify
import json
import random

app = Flask(__name__)
registered_users = set() 
games = {"a":"b", "b":"a"} # this is the dictionary that stores the game state for each user, the key is the username, and the value is the game state
#saved in the format "pipe1_x;pipe1_y|pipe2_x;pipe2_y|...|bird_y,bird_velocity,user_score"
terminalvelocity = 2 # this is the maximum velocity of the bird, it is used to limit the speed of the bird when falling down, the game is 
#pretty hard without it

segmentdisplaydecimal = [119,18,93,91,58,107,111,82,127,123,119] # this is the list of numbers in decimal that represent the segments of the 7-segment display, used to render the score and world record
#the numbers are in the order of 0-9. The numbers are converted to binary in runtime. these are 7 bit numbers, where each bit represents a segment of the display.

ESC = '\x1b'  # This is the ESC character (same as `e in PowerShell). Later used to make coloring faster
pipecharacter1 = f"{ESC}[48;2;0;255;0m " # the three items down starting here are the green pipe colors.
pipecharacter2 = f"{ESC}[48;2;0;196;0m "
pipecharacter3 = f"{ESC}[48;2;139;255;139m "
pipecharacter = f"{pipecharacter1}{pipecharacter3}{pipecharacter1}{pipecharacter2}" # this is a string combining the three colors to produce the final pipe
specialpipecharacter = f"{pipecharacter1}{pipecharacter}{pipecharacter2}" # this is the same as the item above, but adds a pixel on left and right sides of the pipe like in flappy bird
aircharacter = f"{ESC}[0m " #this character is used to render the air, it is just a space with no color
birdcharacter = f"{ESC}[38;2;255;255;0m*" # the next character is used to render the bird, it is a yellow star
numbercharacter = f"{ESC}[48;2;240;240;240m "

global WR
WR = 0 #World Record number
global WRUname
WRUname = "" # World Record's holder username



@app.route("/register/<username>") # this function is used to register a new user. The username is really just used if you beat the world record, so everyone can see who set it.
# there is no need for a password, as if you are gonna beat the world record, you probably want YOUR username to be visible.
# Also this function is used to create a new game for the user and returns the command to paste in powershell to start the game.
def register(username):
    if username not in registered_users:
        registered_users.add(username)
        games[username] = new_game()
    return f"Username {username} successfully registered, here is the command you should paste in powershell:<p> cls; $id = \"" + username + open('powershell.txt','r').read()  + "<p> Here is the command you should paste in bash:<p>clear; stty -echo -icanon time 0 min 0; trap \"stty sane; echo -e '\nExited.'; exit\" SIGINT; id=\"" + username + open('bash.txt','r').read()
    

@app.route('/<a>') # this function acts as a tick function, as it is what is called from the powershell every few milliseconds.
# It takes the username as a parameter, and sends the rendered game state back to the powershell.
def normal(a):
    global games
    global birby
    global birbvel
    games = calculate(games,a,False) #update the game state based on the current state
    return render(a)

@app.route('/jumped/<a>') # this function is the same as the previous one, but it is called when user presses any key to jump.
def jumped(a):
    global games
    global birby
    global birbvel
    games= calculate(games,a,True)#update the game state based on the current state and jumps
    return render(a)

def calculate(games,key,jumped): # this function is the main game logic, it calculates the new game state based on the current state and whether the user jumped or not.

    if key not in games: # if the username is not registered the funtion returns the current game state. Then it is checked in the render function, which returns a message to ask the user to register.
        return games
    
    if games[key].split('|')[0] == "dead": #if you are dead, nothing happens, but if you press any key, a new game starts.
        if jumped:
            games[key] = new_game() # new game starts
            return games
        else:
            return games # nothing happens, later on the render function will return a message to ask the user to start a new game
        
    if games[key].split('|')[0] == "wr": # if you set a new world record, nothing happens, but if you press any key, a new game starts.
        if jumped:
            games[key] = new_game()
            return games # new game starts
        else:
            return games # nothing happens, later on the render function will return a message to ask the user to start a new game
            # and congratulate the user for setting a new world record

    pipes = games[key].split('|')
    # we split the game state into pipes and info about the bird, so we can easily access the pipes and the bird's position and velocity
    # for more info about the format of the game state, see the comment at the top of the file
    for i in range(len(pipes) - 1): # we loop through all the pipes except the last one, which isn't a pipe but the info about the bird
        pipe = pipes[i]
        a = pipe.split(';')                # we split the pipe into its x and y coordinates, so we can easily access them
        if int(a[0]) < 2:                  # if the pipe is about to go off the screen, we remove it and add a new pipe at the end of the list
            pipes.pop(i)                   # remove the pipe from the list
            i-=1                           # we decrease the index by 1, so we don't skip the next pipe
            info = pipes[len(pipes) - 1] # we access the info about the bird and the score (for my sanity i will only be saying info about the bird later on) which is the last element in the list
            pipes.pop(len(pipes) - 1)  # we remove the info about the bird from the list, so we can add a new pipe at the end of the list
            pipes.append(f"86;{str(random.randrange(5,25))}") # adds new pipe, very informative comment, I know
            pipes.append(info) # we put the info about the bird back to the end of the list, so we can access it later
        else:
            pipes[i] = str(int(a[0]) - 1) + ';' + str(a[1]) # in case the pipe is not going off the screen (most of the cases), we just decrease its x coordinate by 1, so it moves to the left

    # now we have the pipes updated, we can move the bird and update its position and velocity score and stuff like that

    info = pipes[len(pipes) - 1].split(',') # this is the info about the bird, which is the last element in the list, we split it into its components: 
    birby = float(info[0])   #birby (y coordinate), 
    birbvel = float(info[1]) #birbvel (velocity) and 
    score = int(info[2])     #score

    if jumped: # if the user jumped, we decreese the bird's velocity by 3, so it goes up (the coordinates are inverted so the top item is zero, the bottom is 30, and the bird goes up when the velocity is negative)
        birbvel-=3
    else:
        if birbvel < terminalvelocity: # if the bird's velocity is less than the terminal velocity, we increase it by 0.5, so it falls down faster
            birbvel+=0.5
        else:
            birbvel = terminalvelocity # if the bird's velocity would have been greater than the terminal velocity, we set it to the terminal velocity, so it doesn't fall down too fast
    birby += birbvel # we add the velocity to the bird's y coordinate, so it moves up or down depending on the velocity



    # So here we implement the dying mechanic for collision with pipes What?! the AI stopped making suggestions for comments :(
    # I guess all the comments so far have overwhelmed it. I guess i will have to continue on my own in this code wasteland.
    if 5 < int(pipes[0].split(';')[0]) < 12: # we check if the bird is under or over the pipe, the distance is also extended to the wierd
        #flappy bird pipe thing as theoretically speaking there is no way someone is getting out of that corner anyway
        if int(pipes[0].split(';')[1]) + 4 < birby or int(pipes[0].split(';')[1]) - 4 > birby: #now this just compares the y to make sure that the bird 
            # is in the pipe before killing it
            return die(games,key,score) # i hope you can figure this out
        
    if birby>30 or birby < 0: # this kills the bird if it goes to high or too low
        return die(games,key,score)
        

    if int(pipes[0].split(';')[0]) == 8: # whenever you pass the pipe you get point++; also you won't get the point if you died from the 
        #pipe as the function already returned 'dead'.
        score+= 1


    pipes[len(pipes) - 1] = f"{str(birby)},{str(birbvel)},{str(score)}" # this changes the info to be updated
    games[key] = '|'.join(pipes) # joins the pipes back into a string and puts it into the games dict

    return games # I had enough let's skip this one, right. I want to publish this on Github today not next month




def die(games,key,score): # kills the player
    games[key] = f"dead|{str(score)}" # changes the game to be dead|[score] , so the score can be displayed
    global WR
    if score > WR: #checks if the player had beaten the world record
        global WRUname
        WR = score
        WRUname = key
        games[key] = f"wr|{str(score)}"
        # if yes updates world record info and changes the game to be we|[score] so we can show the score :boom:
    return games

def render(key): # Ohhh, this is a mess you better prepare

    if key not in games:
        return "Username not found, please register first."
    
    if games[key].split('|')[0] == "dead": # if you are dead, display a fancy window
        return rendermessage(f"You died,\nYour score was: {str(games[key].split('|')[1])}\nPress any key to start a new game\nPress 'q' to quit",-1,-1,-1,f"{ESC}[38;2;255;0;0m")
    
    if games[key].split('|')[0] == "wr": # if you have beaten the wr, display a fancy window
        return rendermessage("Congratulations!!!\nYou set a new world record of " + str(games[key].split('|')[1]) + " points.\nPress any key to start a new game", -1, -1, -1,f"{ESC}[38;2;255;211;44m")
    


    a = games[key] # gets the game
    ret = "" # this is the final string we will be returning
    line = "" # this is a single line
    pipes = a.split('|') # we split the pipes into a list
    info = pipes[len(pipes) - 1] # we record the info before removing it
    pipes.pop(len(pipes) - 1)  # remove the last element, which is the info about the bird

    hpipe = find_highest_pipe(pipes) # we find the highest and the lowest pipes for optimizational purposes
    lpipe = find_lowest_pipe(pipes)
    normalrendering = "" # i'll explain this later
    pipewasbig = False # this also

   #-------------------------------------------------------------
   #wow, you are still reading? Either you are a stalker or idk. I guess i have to be worried

    ret+="World Record of:     By:" + WRUname + ' ' * (90-52-len(WRUname)) + 'Made by Semen Syzonenko 2025\n' # This adds World record info text and 
    # credits


    # this is also absolute shish. The AI hasn't recovered yet. I guess I am stranded here alone, just me my stupid code and VSCode
    # so this part draws all those fancy 7 segment numbers

    numberlist = [] # this list will be used to store score numbers so if your score is 69 it'll store ['6','9']
    numbers = [] # this is where the actual fancy numbers will be stored
    # so i tried restarting VSCode but copilot is nowhere to be seen :`(

    wrnums = [] # this is just a copy of the top one but for the wr numbers

    for number in range(len(str(WR))):
        wrnums.append(rendernumber(int(str(WR)[number]),2,2*numbercharacter)) # so here we add the rendered numbers to a list but if we just printed them
        #like this they would be printed under each other as they are rendered with \n in them
    
    # we are somewhere in half of this program and it is probably get only harder

    score = str(info.split('|')[-1].split(',')[2]) # we get the score
    for number in range(len(score)):
        numbers.append(rendernumber(int(score[number]),2,2*numbercharacter)) #we do the same as above
    
    
    numberlist = wrnums[0].split('\n') # here we set the final numer result list to be the first item of wr, so we know the size
    for y in range(len(numberlist)): # so here we loop through y
        for wrnumber in wrnums[1:]:  # here we loop through the wr numbers
            numberlist[y] += aircharacter * 2 # we add 2 spaces before the number
            numberlist[y] += wrnumber.split('\n')[y] # we add the number
        numberlist[y] += aircharacter * (90 - (10*len(numbers)) - (10*len(wrnums))+2) # we add spaces based on a magic formula i am too lazy to explain
        for number in numbers: # we do the same here
            numberlist[y] += aircharacter * 2
            numberlist[y] += number.split('\n')[y]
        numberlist[y]+= aircharacter * 30 + '\n'  # we add spaces at the end as the powershell command seems to display some request progress, which doesn't
        # look great

    for number in numberlist: # now we add the finalized numbers to the final result, but we haven't even started with pipe rendering, haha
        #:dying inside:
        # i am sure by this point i have written more comments than code, yay
        ret += number


#-------------------------------------------------------------------------------------
# this line is a very cool line, it is a line to visually distunguish (English is not my first language) between the number stuff
# and the pipe stuff
    

# Now let me explain what the actual frick 'normalrendering is'. Well let me do a quick flappy bird ascii drawing
#
#                ####                  ####   So the lines here are indicating which parts are the same:
#                ####                  ####   above the top parts all the rows are the same, below the bottom line it is the same
#----------------####------------------####------------
#                ####                 ######
#                ####
#               ######
#
#
#                                     ######
#                                      ####
#               ######                 ####
#----------------####------------------####-------------
#                ####                  ####    So if we just calculate this once and put it in a variable we can make it faster
#                ####                  ####



    # so that's what we are doing here
    x = 0
    for pipe in pipes: # this code finds how the pipes should look like if there were no holes in the pipes
        normalrendering  += (int(pipe.split(';')[0]) - x) * aircharacter + pipecharacter
        x+= int(pipe.split(';')[0]) - x + 3



    #now here we are looping through y
    for y in range (0,30):
        line = '' # we reset the line
        x = 0
        if ((y > hpipe + 5) or (y < lpipe - 5)):
            #renders the parts of the scene where there are no holes in neither of the pipes
            #basically we add the thing that we calculated above to te line
            line += normalrendering
        else:
            #renders parts where at least one pipe has a hole in it
            #The case where we are between the lines
            for pipe in pipes: # we loop through pipes
                line+=(int(pipe.split(';')[0]) - x) * aircharacter # here we put all the spaces before the next pipe
                x+= int(pipe.split(';')[0]) - x # here we modify the x var to be more consistent with the coordinates


                if abs(int(pipe.split(';')[1]) - y) > 4: # so if in the place we are currently should be a pipe or a hole
                    if abs( int(pipe.split(';')[1]) - y) == 5: # there should be a pipe now is this the place where the pipe is 6 characters big
                        if pipewasbig: # yes, now this whole stuff is just dealing with the offsets cause by the big pipe
                            line+= 2*'\b' + specialpipecharacter
                        else:
                            line+= '\b' + specialpipecharacter
                        pipewasbig = True
                    else:
                        if pipewasbig:
                            line+='\b'+pipecharacter
                            pipewasbig = False
                        else:
                            line+=pipecharacter
                else:
                    line+=aircharacter*4 # this is the place where pipe hole should be. So we add spaces.

                x+=3
        
        # the next codeblock deals with adding the bird character (*) to the 'scene'. It might sound easy untill you remember
        # that we are using color which is usually just some random characters so we do some math to decide where to actually put the 
        # bird character so it appears on the same spot to the viewer
        birby = float(info.split(',')[0])
        if round(birby) == y:
            if int(pipes[0].split(';')[0]) < 10 and (int(pipes[0].split(';')[1]) + 4 < birby or int(pipes[0].split(';')[1]) - 4 > birby):
                if int(pipes[0].split(';')[0]) < 10 and (int(pipes[0].split(';')[1]) + 5 == birby or int(pipes[0].split(';')[1]) - 5 == birby):
                    line = line[:125] + birdcharacter + line[126:]
                else:
                    line = line[:97] + birdcharacter + line[98:]
            else:
                line = line[:49] + birdcharacter + line[50:]

        #some math magic later


        #here we add the line + some spaces+enter
        ret+=line + aircharacter * 5 +'\n'
        pipewasbig = False
        # i guess the pipe ins't big anymore, jk this makes sure that if the last pipe in the line was a big pipe we make sure it won't be 
        # carried to the next line
    #ret+=' '*89+'|' # this is debug for knowing where the 90 mark is, that's where the 'scene should end'
    return ret



def rendermessage(message, maxwidth = -1, xdist = -1, ydist = -1,color = ""): #this just deals with the fancy window
    plus = f"{color}+" 

    ret = ""
    lines = message.split('\n')
    if maxwidth == -1:#calculate width needed for the window if none was specified
        for line in lines:
            if len(line) > maxwidth:
                maxwidth = len(line)

    if xdist == -1: # calculate xdistance if none was specified
        xdist = round(45 - (maxwidth / 2) - 1)

    if ydist == -1: # i am skipping this
        ydist = round(20 - (len(lines) / 2) - 1)

    ret+= '\n' * ydist # adds correct amount of enters before rendering anything else
    ret+= ' ' * xdist + plus + '-' * maxwidth + '+\n' #renders top frame
    for line in lines: # just loops and does stuff i hope you'll understand
        listline = list(line)
        for i in range(len(listline)):
            listline[i] = color + listline[i]
        colorline = ''.join(listline)
        spacedist = round((maxwidth - len(line)) / 2)
        ret+= ' ' * xdist + '|' + ' ' * spacedist + colorline + ' ' * (maxwidth - spacedist - len(line)) + '|\n'

    ret+= ' ' * xdist + '+' + '-' * maxwidth + '+\n' #renders bottom frame

    return ret




def dectobin(num): # converts decimal numbers to binary, stolen from stack overflow
    #print (num)
    res = ''  # binary result

    while num > 0:
        res = str(num & 1) + res
        num >>= 1
    if len(res) < 7:
        res = '0' * (7 - len(res)) + res
    return res

def rendernumber(num, size=3, character = '*',xoffset=0): # this function is just horrible, there is surely a better way to do this
    #but it is made by me so too bad
    # basically this function renders all the segments of the numbers depending on if the binary values of the number are 1 or 0
    retlist = []
    for i in range(3+(2*size)):
        retlist.append(aircharacter* 2 * (2 + size))
    segments = dectobin(segmentdisplaydecimal[num])
    #print(segments)
    if segments[0] == '1':
        retlist[0] = f"  {character * (size)}{aircharacter* 2}"

    if segments[1] == '1' or segments[2] == '1':
        for i in range(0,size):
            if segments[1] == '1' and segments[2] == '1':
                retlist[i + 1] = f"{character}{aircharacter* 2 * size}{character}"
            elif segments[1] == '1':
                retlist[i + 1] = f"{character}{aircharacter* 2 * (size )}{aircharacter* 2}"
            elif segments[2] == '1':
                retlist[i + 1] = f"{aircharacter* 2}{aircharacter* 2 * (size )}{character}"

    if segments[3] == '1':
        retlist[size+1] = f"{aircharacter* 2}{character * (size)}{aircharacter* 2}"


    if segments[4] == '1' or segments[5] == '1':
        for i in range(1 + size,1 + 2*size):
            if segments[4] == '1' and segments[5] == '1':
                retlist[i + 1] = f"{character}{aircharacter* 2 * size}{character}"
            elif segments[4] == '1':
                retlist[i + 1] = f"{character}{aircharacter* 2 * (size )}{aircharacter* 2}"
            elif segments[5] == '1':
                retlist[i + 1] = f"{aircharacter* 2}{aircharacter* 2 * (size )}{character}"

    if segments[6] == '1':
        retlist[-1] = f"{aircharacter* 2}{character * (size)}{aircharacter* 2}"

    for i in range(len(retlist)):
        retlist[i] = aircharacter * xoffset + retlist[i]

    return '\n'.join(retlist)






def load(path): # maybe will be used in the future to prevent information loss in case of power loss or smth
    with open(path) as f:
        return json.load(f)

def save(dict,path):
    with open(path,'w') as f:
        json.dump(dict,f)

def new_game(): # generates new game
    return f"30;{random.randrange(5,25)}|60;{random.randrange(5,25)}|86;{random.randrange(5,25)}|15,0,0"

def find_lowest_pipe(pipes):
    lowest = int(pipes[0].split(';')[1])
    lpipe = 0
    i = 0
    for pipe in pipes:
        a = pipe.split(';')
        if int(a[1]) < lowest:
            lowest = int(a[1])
            lpipe = i
        i += 1
    return lowest

def find_highest_pipe(pipes):
    highest = int(pipes[0].split(';')[1])
    hpipe = 0
    i = 0
    for pipe in pipes:
        a = pipe.split(';')
        #print (pipe)
        if int(a[1]) > highest:
            highest = int(a[1])
            hpipe = i
        i += 1
    return highest

#Wow, I have made it to the botttom, i see you've made it here too. Congrats...
#But at what cost?

#Ok i have nothing much to say, i'll just put some gen alpha slang here, cause why not:

#skibidi ohio w rizz



